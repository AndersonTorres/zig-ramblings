# -*- mode: org; coding: utf-8-unix; fill-column: 80 -*

* Capítulo 1

  Este capítulo dá uma visão geral da linguagem Zig, mediante exemplos
  práticos. Exibiremos e analisaremos diversos códigos completos a fim de
  ilustrar os conceitos da linguagem. Evitamos adentrar em detalhes técnicos
  neste capítulo, dado que teremos espaço para isso nos capítulos futuros.

** Considerações Gerais

    De maneira geral, um computador contém uma coleção de programas e arquivos
    especiais, os quais formam aquilo que chamamos de /sistema operacional/.
    Existe uma gama bastante variada de sistemas operacionais, indo desde os
    mais conhecidos comercialmente Windows e Mac OS X até outros com maior apelo
    técnico no mundo /open source/ como as distribuições Linux, os descendentes
    do BSD (FreeBSD, NetBSD, OpenBSD) e até mesmo projetos de reavivamento como
    o FreeDOS e o Haiku OS, este último inspirado no extinto BeOS.

    Um sistema operacional tem por objetivo gerenciar os recursos da máquina e
    fornecer interfaces convenientes entre estes recursos e os seus usuários.

    Entre os diversos recursos fornecidos pelo sistema operacional, estão
    editores de texto e interpretadores de linguagens de programação. Comumente
    estes editores e interpretadores são distribuídos de forma independente
    entre si; porém, não é incomum a presença de ambientes integrados de
    programação. De fato, existem pacotes de integração que costumam ser mais
    famosos que seus próprios componentes individuais, como as IDEs
    comercializadas pela Borland e Microsoft.

    Por ora, vamos assumir que o leitor consiga criar e editar arquivos de texto
    contendo código Zig, além de acesso a uma shell de comandos e do compilador
    Zig oficial. Mais adiante, vamos comentar o processo de obter um ambiente
    apropriado para esta tarefa.

** Conceitos

*** Um Programa Simples

    Vamos começar com um programa simples que exibe uma frase na tela do
    terminal.

    Escreva o texto abaixo em um arquivo com o nome terminado em =.zig=, digamos
    =hello.zig=.

    #+begin_src zig :mkdirp yes :tangle ./code/chapter-01/hello.zig
      const std = @import("std");
      const dprint = std.debug.print;

      pub fn main() void {
          dprint("{s}", .{"Hello, World!\n"});
      }
    #+end_src

**** Execução

     Agora, para compilar este programa, execute o comando =zig build-exe
     hello.zig=. Se o código não contiver erros que impeçam uma compilação
     bem-sucedida, um arquivo de mesmo nome mas com extensão diferente será
     criado como resultado, no caso, =hello=. Podemos então executá-lo:

     #+begin_example
     $> zig build-exe hello.zig
     $> ./hello
     Hello, World!
     $>
     #+end_example

**** Destrinchando

    Vamos então percorrer este programa linha a linha:

    #+begin_src zig
      const std = @import("std");
    #+end_src

    Esta é uma típica atribuição. Vamos destrinchá-la:

    - =const= é uma palavra reservada[fn:1] da linguagem Zig; ela tem um
      propósito distinto, e é tratada de uma maneira especial pelo compilador.
      Especificamente, ela indica que o identificador =std= é uma constante,
      armazenando um valor imutável.

    - =std= é um identificador. Identificadores servem para identificar,
      fornecer uma identidade a uma entidade utilizada no programa.

    - =@import( ... )= é uma função embutida na linguagem Zig. Esta função tem
      uma funcionalidade bastante importante: ela recebe como parâmetro a
      localização, no sistema de arquivos, onde se situa um arquivo escrito na
      linguagem Zig, e retorna uma estrutura correspondente a este
      arquivo. [fn:: Na linguagem Zig, um arquivo contendo código-fonte Zig é
      tratado como uma =struct=.].

      Normalmente, =@import= recebe como parâmetro o caminho relativo ao arquivo
      desejado; porém, há alguns valores especiais que este parâmetro pode
      assumir. Por exemplo, ="std"= representa a biblioteca-padrão de Zig.

   Sumarizando esta linha: =std= é uma constante que armazena a
   biblioteca-padrão de Zig.

    #+begin_src zig
      const dprint = std.debug.print;
    #+end_src

    Da biblioteca =std=, vamos utilizar uma função para exibir frases na tela, a
    saber, =std.debug.print=. Como o nome sugere, ela costuma ser utilizada para
    "debug print", uma antiga técnica de depuração que consiste em emitir
    mensagens na tela a fim de rastrear o comportamento de um programa.

    Para escrever menos, atribuímos a ela o identificador =dprint=.[fn:: De
    fato, poderíamos ter escrito =@import("std").debug.print( ... )=
    diretamente, todavia isto sacrificaria muito da legibilidade do programa.]

    #+begin_src zig
      pub fn main() void {
    #+end_src

    Esta é uma declaração de função. Vamos destrinchá-la:

    - A palavra-chave =pub= indica que o objeto definido (a saber, =main=) será
      /público/. Isto significa que ele estará visível acaso algum código Zig a
      importe.

    - A palavra-chave =fn= indica que o objeto definido - a saber, =main= -
      trata-se de uma função.

      A função =main= tem um propósito especial em Zig. Ela indica ao compilador
      onde o programa inicia sua execução (no jargão, =main= é o /ponto de
      entrada/ do programa). Normalmente, programas feitos para serem executados
      dependem de uma função =main= que seja pública.[fn:2]

    - Por fim, =void= é mais uma palavra reservada; especificamente aqui, ela
      indica que a função =main()= retorna =void= (ou seja, ela não retorna
      valor algum para quem a chamou).

    - As chaves ={ ... }= envolvem o corpo de uma definição de função. Mais
      geralmente, chaves servem para agrupar comandos e outros tipos de
      declaração.

    #+begin_src zig
          dprint("{s}", .{"Hello, World!\n"});
    #+end_src

    Aqui estamos de fato empregando a função =dprint()=. Não adentraremos em
    detalhes de seu funcionamento neste momento, mas é possível falar do básico:

    Esta função recebe dois parâmetros. O primeiro, ="{s}"=, é uma string de
    formatação, enquanto o segundo, =.{"Hello, World!\n"}= é uma struct anônima
    que serve de parâmetro para a string de formatação.

*** Variáveis, Expressões e Atribuições

    Como ilustração, vamos escrever um programa que converte escalas de
    temperatura.

    #+begin_src zig :mkdirp yes :tangle ./code/chapter-01/temperature.zig
      const std = @import("std");
      const dprint = std.debug.print;

      pub fn main() void {
          var celsius_temperature: f32 = 100;
          var kelvin_temperature: f32 = undefined;
          var fahrenheit_temperature: f32 = undefined;

          // celsius to kelvin conversion
          kelvin_temperature = celsius_temperature + 273.16;
          fahrenheit_temperature = 9*(kelvin_temperature - 273.16)/5 + 32; // kelvin to fahrenheit conversion

          const format = "\tCelsius: {d:.3}\n\tFahrenheit: {d:.3}\n\tKelvin: {d:.3}\n";

          dprint(format, .{celsius_temperature,
                           fahrenheit_temperature,
                           kelvin_temperature});
      }
    #+end_src

**** Execução

     Outra forma de executar programas Zig é invocando o comando =zig run=. Este
     comando não gera um arquivo executável; em vez disso, ele executa o programa
     diretamente. [fn:: Veteranos acostumados com linguagens interpretadas como
     Python reconhecerão a semelhança!]

     #+begin_example
     $> zig run temperature.zig
         Celsius: 100.000
         Fahrenheit: 212.000
         Kelvin: 373.160
     $>
     #+end_example

**** Destrinchando

    #+begin_src zig
          var celsius_temperature: f32 = 100;
    #+end_src

    Esta é uma declaração de variável, como indicado pela palavra-chave =var=.
    Em geral, declarações e expressões em geral finalizam com um ponto-e-vírgula
    =;=.

    A palavra-chave =f32= indica que o valor armazenado pelo identificador
    =celsius_temperature= será do tipo =f32= - um ponto flutuante de 32
    bits. Inicializamos este valor com =100=.

    #+begin_src zig
          var kelvin_temperature: f32 = undefined;
          var fahrenheit_temperature: f32 = undefined;
    #+end_src

    Em Zig, é obrigatório inicializar as variáveis com algum valor. Caso não
    seja possível ou viável inicializar alguma variável com um valor concreto,
    usa-se para tal a palavra-chave =undefined= em seu lugar.

    #+begin_src zig
          // celsius to kelvin conversion
    #+end_src

    Esta linha é um comentário. Em Zig, comentários iniciam com =//= e encerram
    no fim da linha (LF - o caractere /linefeed/). O compilador ignora os
    comentários, não os transformando em código executável.

    Zig não tem o conceito de "comentário multi-linha" (como, por exemplo,
    comentários =/* ... */= em C++).

    #+begin_src zig
          kelvin_temperature = celsius_temperature + 273.16;
    #+end_src

    Esta é uma atribuição, como indicada pelo sinal ===. O valor da expressão do
    lado direito é atribuído à variável do lado esquerdo. Como já é esperado, as
    operações matemáticas seguem as regras de precedência e associatividade com
    as quais estamos acostumados: multiplicações e divisões são efetuadas antes
    de adições e subtrações.[fn:3]

    #+begin_src zig
          fahrenheit_temperature = 9*(kelvin_temperature - 273.16)/5 + 32; // kelvin to fahrenheit conversion
    #+end_src

    Como antes, esta é uma atribuição. Operações contidas entre parênteses são
    efetuadas primeiro.

    A título de demonstração, há um comentário após esta atribuição; comentários
    podem começar em qualquer posição de uma linha, estendendo-se até o fim da
    linha, como de costume.

    #+begin_src zig
          const format = "\tCelsius: {d:.3}\n\tFahrenheit: {d:.3}\n\tKelvin: {d:.3}\n";
    #+end_src

    Nesta linha, é atribuída a =format= uma cadeia de caracteres (vulgarmente
    conhecida como /string/). Esta string tem algumas particularidades que valem
    ser mencionadas.

    A primeira: as sequências de caracteres =\t= e =\n= são chamados /caracteres
    de escape/, e têm um significado especial. =\t= é o caractere de tabulação
    (TAB), e o caractere =\n= é o caractere que indica o início de uma nova
    linha.

    A segunda: os gabaritos de formatação ={d:.3}=. Eles são interpretados pela
    função =dprint=, e servem para determinar como os demais parâmetros serão
    impressos. Neste caso específico, serão numerais (=d=) impressos com 3 casas
    decimais após o ponto (=.3=).

    #+begin_src zig
          dprint(format, .{celsius_temperature,
                           fahrenheit_temperature,
                           kelvin_temperature});
      }
    #+end_src

    Esta é a função =dprint()=. O primeiro parâmetro já foi explicado antes. O
    segundo, como já foi dito, representa uma struct anônima com três campos, os
    quais serão relacionados com os gabaritos ={d:.3}= de =format=.
